import { test, expect, Page } from "@playwright/test";
import process from "process";

export const testAssetsPath = process.cwd().includes("packages")
  ? "tests/fixtures/" // for nx
  : "packages/studio-web/tests/fixtures/"; //for vscode
export const testText = `This is a test.
Sentence.

Paragraph.


Page.`;
export const testMp3Path =
  testAssetsPath + "test-sentence-paragraph-page-56k.mp3";
/**
 * Steps to recreate a readalong for tests
 */
export const testMakeAReadAlong = async (page: Page) => {
  await test.step("generate the readalong", async () => {
    await page.getByTestId("ras-text-input").fill(testText);

    await page
      .getByTestId("audio-btn-group")
      .getByRole("radio", { name: "File" })
      .click();
    await page.getByTestId("ras-audio-fileselector").click({ force: true });
    await page.getByTestId("ras-audio-fileselector").setInputFiles(testMp3Path);
    await expect(async () => {
      await expect(
        page.getByTestId("next-step"),
        "model is loaded",
      ).not.toBeDisabled();

      //create the readalong
      await page.getByTestId("next-step").click();
    }).toPass();

    //wait for edit page to load
    await expect(async () => {
      await expect(page.getByTestId("ra-header")).toBeVisible({ timeout: 0 });
      await expect(page.getByTestId("ra-header")).toBeEditable();
      //edit the headers

      await page
        .getByTestId("ra-header")
        .fill("Sentence Paragraph Page", { force: true });

      await expect(page.getByTestId("ra-header")).toHaveValue(
        "Sentence Paragraph Page",
      );
    }).toPass();

    await page
      .getByTestId("ra-subheader")
      .fill("by me", { force: true, timeout: 0 });
    await expect(page.getByTestId("ra-subheader")).toHaveValue("by me");

    //add translations
    await page
      .locator("#t0b0d0p0s1")
      .getByTestId("add-translation-button")
      .waitFor({ state: "visible" });
    await page
      .locator("#t0b0d0p0s0")
      .getByTestId("add-translation-button")
      .click(); //{ force: true, timeout: 0 });

    await page
      .locator("#t0b0d0p0s1")
      .getByTestId("add-translation-button")
      .click(); //{ force: true, timeout: 0 });
    await page
      .locator("#t0b0d0p1s0")
      .getByTestId("add-translation-button")
      .click(); //{ force: true, timeout: 0 });
    //update translations
    await page
      .locator("#t0b0d0p0s0translation")
      .fill("Ceci est un test.", { force: true, timeout: 0 });
    await expect
      .soft(page.locator("#t0b0d0p0s0translation"))
      .toContainText("Ceci est un test.");
    await page
      .locator("#t0b0d0p0s1translation")
      .fill("Phrase.", { force: true, timeout: 0 });
    await expect
      .soft(page.locator("#t0b0d0p0s1translation"))
      .toContainText("Phrase.");
    await page
      .locator("#t0b0d0p1s0translation")
      .fill("Paragraphe.", { force: true, timeout: 0 });
    await expect
      .soft(page.locator("#t0b0d0p1s0translation"))
      .toContainText("Paragraphe.");

    //upload a photo to page 1
    let fileChooserPromise = page.waitForEvent("filechooser");
    page.locator("#fileElem--t0b0d0").dispatchEvent("click");

    let fileChooser = await fileChooserPromise;
    fileChooser.setFiles(testAssetsPath + "page1.png");

    await page.locator("#t0b0d0p0s0w0").dispatchEvent("click");
    //upload a photo to page 2
    fileChooserPromise = page.waitForEvent("filechooser");
    page.locator("#fileElem--t0b0d1").dispatchEvent("click");
    fileChooser = await fileChooserPromise;
    fileChooser.setFiles(testAssetsPath + "page2.png");
    for(const toast of await page.locator("div.toast-message").all()){
        await toast.click({ force: true });
    }
    await expect(async () => {
      await expect(page.locator("div.toast-message")).not.toBeVisible();
    }).toPass();
  });
};

/* default before each */
export const defaultBeforeEach = async (page: Page, browserName: string) => {
  test.step("setup test", async () => {
    test.skip(
      browserName === "webkit",
      "The aligner feature is not stable for webkit",
    );
    await expect(async () => {
      await page.goto("/", { waitUntil: "load" });
      await expect(
        page.getByTestId("next-step"),
        "Soundswallower model has loaded",
      ).not.toBeDisabled();

      await disablePlausible(page);
    }).toPass();
  });
};

/**
 * @param text:string
 * @return text:string
 * Timestamps generated by alignment can be off by a couple of microseconds.
 * The point of the test is check format not the values generated,
 * therefore we zero the values to restrict the comparison to format checking
 */
export const replaceValuesWithZeroes = (text: string): string => {
  return text.replace(/\d/g, "0");
};

export const disablePlausible = async (page: Page) => {
  //disable plausible
  await page.evaluate(
    async () => await window.localStorage.setItem("plausible_ignore", "true"),
  );
};

/**
 * Uploads single file html (setup editor test)
 * @param page
 */
export const editorDefaultBeforeEach = async (
  page: Page,
  isMobile: boolean,
) => {
  test.step("upload single file html", async () => {
    await page.goto("/", { waitUntil: "load" });
    disablePlausible(page);
    if (isMobile) {
      await page.getByTestId("menu-toggle").click();
    }
    await page
      .getByRole(isMobile ? "menuitem" : "button", { name: /Editor/ })
      .click();

    await page.locator("#updateRAS").waitFor({ state: "visible" });
    let fileChooserPromise = page.waitForEvent("filechooser");
    await page.locator("#updateRAS").click();
    let fileChooser = await fileChooserPromise;
    fileChooser.setFiles(testAssetsPath + "sentence-paragr.html");
    await expect(
      page.locator("#audioToolbar"),
      "audio bar should exist",
    ).toHaveCount(1);
    //check readalong
    await expect(
      page.locator("#readalongContainer"),
      "should check that readalong is loading",
    ).not.toBeEmpty();
    await page.locator("#t0b0d0").waitFor({ state: "visible" });
    await expect(async () => {
      await expect(
        page.locator("#t0b0d0"),
        "read along has been loaded",
      ).toHaveCount(1);
    }).toPass();
  });
};
